const l=(e,r,t)=>{var a=e.createShader(r);if(e.shaderSource(a,t),e.compileShader(a),e.getShaderParameter(a,e.COMPILE_STATUS))return a;throw new Error(`Erro ao compilar shader (${r}): `+e.getShaderInfoLog(a))},g=(r,t,...e)=>{if(e.forEach(e=>r.attachShader(t,e)),r.linkProgram(t),!r.getProgramParameter(t,r.LINK_STATUS))throw new Error("ERROR linking program!"+r.getProgramInfoLog(t));if(r.validateProgram(t),r.getProgramParameter(t,r.VALIDATE_STATUS))return t;throw new Error("ERROR validating program!"+r.getprogramInfoLog(t))};const t=document.getElementById("cContainer"),a=document.getElementById("cTitle"),o=document.getElementById("cText"),n=((e,r,t)=>{const o=document.getElementById(e),n=(e=>{if(!e)throw new Error("Canvas não encontrado");e.style.display="block";e=e.getContext("webgl")||e.getContext("experimental-webgl");if(e)return e;throw new Error("webGL não suportado")})(o);o.width=t*o.clientWidth,o.height=t*o.clientHeight,n.viewport(0,0,o.width,o.height);e=l(n,n.VERTEX_SHADER,` precision mediump float; attribute vec4 vertPosition; varying vec2 Position; void main() { Position = vertPosition.xy; gl_Position = vertPosition; }`),r=r?l(n,n.FRAGMENT_SHADER,r):null;const a=g(n,n.createProgram(),e,r);n.useProgram(a);e=n,r=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,r);n.bufferData(n.ARRAY_BUFFER,new Float32Array([1,1,-1,1,-1,-1,1,-1]),n.STATIC_DRAW);e=n.getAttribLocation(a,"vertPosition");n.vertexAttribPointer(e,2,n.FLOAT,n.FALSE,2*Float32Array.BYTES_PER_ELEMENT,0),n.enableVertexAttribArray(e);const i=(new Date).getTime(),c=[0,0];var s,d;return{draw:(e=i)=>{var r=n.getUniformLocation(a,"Resolution"),r=(n.uniform2fv(r,[o.width,o.height]),n.getUniformLocation(a,"Time")),r=(n.uniform1f(r,i-e),n.getUniformLocation(a,"Mouse"));n.uniform2fv(r,c),n.drawArrays(n.TRIANGLE_FAN,0,4)},destroy:()=>{return e=n,r=o,t=r.id,(a=r.parentNode).removeChild(r),(r=document.createElement("canvas")).style.display="none",r.id=t,a.prepend(r),e.bindBuffer(e.ARRAY_BUFFER,null),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.bindRenderbuffer(e.RENDERBUFFER,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteProgram(program),e.deleteShader(fragmentShader),e.deleteShader(vertexShader),e.deleteBuffer(vertexBufferObject),void(e.canvas.width=e.canvas.height=1);var e,r,t,a},update:(s=n,d=a,e=>{var e=l(s,s.FRAGMENT_SHADER,e),[r,t]=s.getAttachedShaders(d);s.detachShader(d,t),d=g(s,d,e,r),s.useProgram(d)}),mouse:c,resScale:t,canvas:o,gl:n}})("c",` precision mediump float; uniform float Time; uniform vec2 Resolution; uniform vec2 Mouse; varying vec2 Position; void main() { gl_FragColor = vec4(.0); }`,2);window.setInterval(()=>n.draw((new Date).getTime()),1e3/24),n.canvas.addEventListener("mousemove",e=>{n.mouse[0]=2*n.resScale*e.offsetX/n.canvas.width-1,n.mouse[1]=2*(n.canvas.height-n.resScale*e.offsetY)/n.canvas.height-1});const i=async e=>{return(await fetch(`fragments/${e}.frag`)).text()},r=async e=>{try{t.style.display="none";var r=await i(e);return n.update(r),e!==a.innerHTML&&(a.innerHTML=e,o.innerHTML=r,console.log("Shader alterado para "+e)),t.style.display="block",!0}catch(e){return console.error(e),!1}};let c=()=>!1;if((async e=>await r(e)&&await c(e))("initial"),location.origin.includes("10001")){const s=new WebSocket("ws://localhost:10001/watch");s.onmessage=e=>{console.log("asdfasdf"),r(a.innerHTML)},s.onopen=e=>{(c=async e=>{try{return await s.send(e),!0}catch(e){return console.error(e),!1}})(a.innerHTML)}}